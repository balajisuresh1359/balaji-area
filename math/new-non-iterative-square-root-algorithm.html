<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Balaji | Math</title>
  <link href="../styles/index.css" rel="stylesheet">
  <link href="./styles/index.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script defer src="../script/common.js"></script>
  <style>  
        h1 {
            font-size: 1.5em;
            margin-bottom: 5px;
        }
        .abstract {
            font-style: italic;
            margin: 20px 30px;
            text-align: justify;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        .equation {
            display: block;
            text-align: center;
            margin: 15px 0;
        }
        .algorithm {
            /* background-color: #f9f9f9; */
            padding: 15px;
            border: 1px solid #ddd;
            margin: 15px 0;
        }
        .algorithm ol {
            counter-reset: item;
            padding-left: 20px;
        }
        .algorithm li {
            counter-increment: item;
            margin-bottom: 5px;
        }
        .algorithm li::before {
            content: counter(item) ": ";
            font-weight: bold;
        }
        .algorithm .comment {
            /* color: #666; */
            font-style: italic;
        }
        .caption{
          text-align: center;
          margin-bottom: 1em;
        }

  </style>
  </head>
<body>
  <nav class="bg-gray-800 text-white p-4">
    <div class="container mx-auto flex justify-between items-center">
      <a href="../index.html" class="font-bold text-xl">Balaji Suresh Babu</a>
      <div class="flex items-center">
        <button id="theme-toggle-mobile" class="md:hidden mr-4 flex items-center justify-center">🌙</button>
        <button id="menu-toggle" class="md:hidden text-2xl focus:outline-none">☰</button>
      </div>      
      <div id="nav-links" class="hidden md:flex space-x-4 items-center">
        <a href="../blog/index.html" class="px-4">Blog</a>
        <a href="./index.html" class="px-4">Math</a>
        <a href="../code/index.html" class="px-4">Code</a>
        <a href="../contact.html" class="px-4">Contact</a>
        <button id="theme-toggle" class="ml-4">🌙</button>
      </div>
    </div>
    <div id="mobile-menu" class="hidden bg-gray-700 flex flex-col text-center py-2">
      <a href="../blog/index.html" class="py-2">Blog</a>
      <a href="./index.html" class="py-2">Math</a>
      <a href="../code/index.html" class="py-2">Code</a>
      <a href="../contact.html" class="py-2">Contact</a>
    </div>
  </nav>
  <main class="container mx-auto p-6">
    <h1 style="margin-top: 2em;" class="text-4xl font-bold mb-4" style="margin-top: 1em;">New Non-Iterative Square Root Algorithm: MXB</h1 style="margin-top: 2em;">
    <hr>

    <p class="text-gray-500 text-sm italic mb-4">Posted on: <span class="font-semibold">March 17, 2025</span></p>
    
    <div class="abstract">
        <p>The computation of square roots has been a fundamental mathematical operation for thousands of years, with numerous algorithms developed throughout history. From the Babylonian method to Newton-Raphson iteration and modern hardware implementations, mathematicians and computer scientists have continually sought faster and more accurate approaches. Despite this rich history, most square root algorithms share a common limitation: they require iterative processes to achieve high precision. This paper introduces a new non-iterative formula that calculates square roots with remarkable accuracy in a single computational step, offering potential advantages for applications where computational efficiency is paramount.</p>
    </div>
    
    <h1 style="margin-top: 2em;">Introduction</h1 style="margin-top: 2em;">
    <p>In this MXB square root method, we need to find the nearest perfect square to the number. First, notice that there are 2n+1 parts between n² and (n+1)². This means we can split the interval between n and n+1 into 2n+1 equal parts.</p>
    
    <p><strong>Example:</strong> For numbers 4 &amp; 5, 4² = 16 and 5² = 25. Between 4 and 5, consider one rectangle with the starting point at 4 and ending at 5. We can split this rectangle into 9 (2(4)+1) parts equally, each box having a width of 1/(2n+1). This is a mathematical fact.</p>
    
    <p>Let's consider finding the square root of 18 that lies between 16 and 25. Can we use this logic?
    4² = 16, and we can have 2(4)+1 = 9 parts between 4 and 5. For 18, which is 2 places after 16, would adding two parts give us the square root?
    There are 9 parts, and we need two box widths since 18-16 = 2, so:</p>
    
    <div class="equation">
        4 + 1/(2(4)+1) + 1/(2(4)+1) = 4 + 2/9 = 4.2222...
    </div>
    
    <p>Squaring this result: 4.2222...² = 17.827160492, which is not 18.
    If a number is between 16 and 25, and we're trying to split the square roots of these numbers (4 &amp; 5) equally, shouldn't the square roots of numbers in this range increase proportionally? Actually, no. This approach is incorrect as we'll see below.</p>
    
    <div class="image-container">
        <img src="./images/between-4-and-5-eq-parts.png" alt="Equal parts between 4 and 5" class="article-image">
    </div>
    <div class="caption">Figure 1: Equal parts between 4 and 5</div>

    
    <p>In the image below, you can see the gaps between each square root of numbers from 16 to 25. They are not evenly spaced:</p>
    
    <div class="image-container">
        <img src="./images/sq-roots-between-4-and-5.png" alt="Square roots between 4 and 5" class="article-image">
    </div>
    <div class="caption">Figure 2: Square roots between 4 and 5</div>

    
    <p>So, if we follow the previous approach, we can't get an accurate result.
    However, we can notice that when we check larger numbers, the gaps appear more evenly distributed:</p>
    
    <div class="image-container">
        <img src="./images/15-and-16.png" alt="Square roots between 15 and 16" class="article-image">
    </div>
    <div class="caption">Figure 3: Square roots between 15 and 16</div>

    
    <h1 style="margin-top: 2em;">Analysis of Differences</h1 style="margin-top: 2em;">
    <p>Differences between consecutive square roots from √16 to √25:</p>
    
    <table>
        <tr>
            <td>√16 = 4.0000</td>
            <td></td>
        </tr>
        <tr>
            <td>√17 = 4.1231</td>
            <td>Difference: 0.1231</td>
        </tr>
        <tr>
            <td>√18 = 4.2426</td>
            <td>Difference: 0.1195</td>
        </tr>
        <tr>
            <td>√19 = 4.3589</td>
            <td>Difference: 0.1163</td>
        </tr>
        <tr>
            <td>√20 = 4.4721</td>
            <td>Difference: 0.1132</td>
        </tr>
        <tr>
            <td>√21 = 4.5826</td>
            <td>Difference: 0.1105</td>
        </tr>
        <tr>
            <td>√22 = 4.6904</td>
            <td>Difference: 0.1078</td>
        </tr>
        <tr>
            <td>√23 = 4.7958</td>
            <td>Difference: 0.1054</td>
        </tr>
        <tr>
            <td>√24 = 4.8990</td>
            <td>Difference: 0.1032</td>
        </tr>
        <tr>
            <td>√25 = 5.0000</td>
            <td>Difference: 0.1010</td>
        </tr>
    </table>

    <div class="image-container">
      <img src="./images/line-4-9.png" alt="Line from 4 to 9" class="article-image">
    </div>
    <div class="caption">Figure 4: Line from 4 to 9: Square root differences between 4 and 9</div>


        
    <p>If the line looks almost straight, then the distribution of square roots in this range is more evenly distributed. If you look at the image below, you can see that it doesn't look straight for smaller numbers but appears almost straight for larger numbers.</p>
    
    <div class="image-container">
        <img src="./images/line-10-11.png" alt="Line from 10 to 11: Square root differences" class="article-image">
    </div>
    <div class="caption">Figure 5: Line from 10 to 11: Square root differences between 100 and 121</div>

    
    <p>We can't rely solely on these distributions, but we can use them for our calculations.</p>
    
    <h1 style="margin-top: 2em;">Derivation of the Formula</h1 style="margin-top: 2em;">
    <p>To find the square root of any number, we need:</p>
    <ol>
        <li>The nearest perfect square number that is smaller than our target number. Let's call this b.</li>
        <li>We need to create a relationship between these numbers.</li>
    </ol>
    
    <p>Let's call our number x and its nearest perfect square number b.
    Our equation will look like:</p>
    
    <div class="equation">
        b + one-number-in-decimal = √(b² + difference-between-b²-and-x)
    </div>
    
    <div class="equation">
        b + a = √(b² + (x - b²))
    </div>
    
    <p>where a is some decimal number we need to find.
    If we solve this equation, we get b + a = √x, which doesn't help us proceed further.
    So, let's replace x - b² with m (the difference between x and b²):</p>
    
    <div class="equation">
        b + a = √(b² + m)
    </div>
    
    <p>Now we can manipulate this equation. First, let's square both sides:</p>
    
    <div class="equation">
        b² + a² + 2ab = b² + m
    </div>
    
    <p>Simplifying:</p>
    
    <div class="equation">
        a² + 2ab = m<br>
        a(a + 2b) = m<br>
        a = m/(a + 2b)
    </div>
    
    <p>Here we can substitute the value of a on the right side infinitely:</p>
    
    <div class="equation">
        a = m/(m/(m/(...) + 2b) + 2b) + 2b)
    </div>
    
    <p>This would go on forever. To break this cycle and simplify our calculations, I'll substitute an approximation for a, which is 1/(2b+1). This isn't the exact value of a, but it gives a close approximation.
    After substitution:</p>
    
    <div class="equation">
        a = m/(m/(m/(1/(2b+1) + 2b) + 2b) + 2b)
    </div>
    
    <p>This can be simplified to:</p>
    
    <div class="equation">
        a = (m²(4b+1) + 4mb²(2b+1))/(m² + 4b(4b³ + 2b² + 3bm + m))
    </div>
    
    <p>This is MXB Square Root formula to find the value of a if x lies between b² and (b+1)².</p>
    
    <h1 style="margin-top: 2em;">Theoretical Foundation</h1 style="margin-top: 2em;">
    <p>The choice of 1/(2b+1) as an approximation for a in MXB formula has a solid theoretical foundation. When we analyze the interval between consecutive integers n and n+1, we observe that there are exactly 2n+1 distinct perfect squares between n² and (n+1)². This mathematical property allows us to divide the interval between √(n²) and √((n+1)²) (or simply between n and n+1) into 2n+1 equal parts.</p>
    
    <p>Each part has a width of 1/(2n+1). In MXB formula, b represents the integer square root of our target number (equivalent to n in this explanation), so the width of each part becomes 1/(2b+1). This value serves as our initial approximation to stop the infinite substitution chain in our recursive formula.</p>
    
    <p>While this approximation alone is not sufficient for high precision (as demonstrated in our earlier example with the square root of 18), it provides a critical starting point for our non-iterative approach. By incorporating this value into our more sophisticated formula, we achieve the remarkable accuracy demonstrated in our results.</p>
    
    <h1 style="margin-top: 2em;">Complexity Analysis</h1 style="margin-top: 2em;">
    <p>One of the primary advantages of our non-iterative square root algorithm is its computational efficiency. Let's analyze its complexity and compare it with traditional approaches.</p>
    
    <h1 style="margin-top: 2em;">Time Complexity</h1 style="margin-top: 2em;">
    <p>MXB algorithm has a time complexity of O(1) (constant time) because it performs a fixed number of arithmetic operations regardless of the input size. The operations include:</p>
    <ul>
        <li>Finding the largest perfect square less than the input (O(1) using built-in square root functions)</li>
        <li>Computing the formula using basic arithmetic operations (O(1))</li>
    </ul>
    
    <p>In contrast, iterative methods like Newton-Raphson or the Babylonian method have a time complexity of O(log n) where n represents the required precision. This is because they need multiple iterations to converge to the desired accuracy.</p>
    
    <h1 style="margin-top: 2em;">Space Complexity</h1 style="margin-top: 2em;">
    <p>MXB algorithm has a space complexity of O(1) since it requires only a constant amount of memory regardless of the input size.</p>
    
    <h1 style="margin-top: 2em;">Performance Considerations</h1 style="margin-top: 2em;">
    <p>While traditional iterative methods may require 5-10 iterations to achieve high precision, our formula delivers comparable precision in a single step. This makes our approach particularly valuable for:</p>
    <ul>
        <li>Real-time applications where computational latency is critical</li>
        <li>Embedded systems with limited computational resources</li>
        <li>High-throughput scenarios requiring numerous square root calculations</li>
    </ul>
    
    <h1 style="margin-top: 2em;">Comparison with Existing Methods</h1 style="margin-top: 2em;">
    <p>To understand the advantages and potential limitations of our non-iterative approach, let's compare it with traditional square root algorithms.</p>
    
    <table>
        <caption>Comparison of Square Root Methods</caption>
        <tr>
            <th>Method</th>
            <th>Type</th>
            <th>Time Complexity</th>
            <th>Precision</th>
            <th>Use Case</th>
        </tr>
        <tr>
            <td>MXB Square Root</td>
            <td>Non-iterative</td>
            <td>O(1)</td>
            <td>High</td>
            <td>General purpose, real-time applications</td>
        </tr>
        <td>Newton-Raphson</td>
            <td>Iterative</td>
            <td>O(log n)</td>
            <td>Very high</td>
            <td>Scientific computing</td>
        </tr>
        <tr>
            <td>Babylonian</td>
            <td>Iterative</td>
            <td>O(log n)</td>
            <td>High</td>
            <td>General purpose</td>
        </tr>
        <tr>
            <td>Binary Search</td>
            <td>Iterative</td>
            <td>O(log n)</td>
            <td>Medium</td>
            <td>Simple implementations</td>
        </tr>
        <tr>
            <td>Taylor Series</td>
            <td>Iterative</td>
            <td>O(n)</td>
            <td>Variable</td>
            <td>Near a known value</td>
        </tr>
        <tr>
            <td>Digit-by-digit</td>
            <td>Iterative</td>
            <td>O(n)</td>
            <td>Controlled</td>
            <td>Educational purposes</td>
        </tr>
        <tr>
            <td>Hardware Methods</td>
            <td>Non-iterative</td>
            <td>O(1)</td>
            <td>Medium-High</td>
            <td>CPU/GPU implementations</td>
        </tr>
    </table>
    
    <h1 style="margin-top: 2em;">Accuracy Comparison</h1 style="margin-top: 2em;">
    <p>The MXB formula demonstrates remarkable accuracy with a mean absolute error of 2.28 × 10<sup>-7</sup>, which is approximately 1.35 × 10<sup>8</sup> times more accurate than Newton's method with 5 iterations. Similarly, the maximum error observed for the MXB formula (1.28 × 10<sup>-3</sup>) is approximately 6 × 10<sup>4</sup> times smaller than Newton's method's maximum error.</p>
    
    <table>
        <caption>Comparison of error metrics between MXB Formula and Newton Method with 5 iterations for number 1 to 10000</caption>
        <tr>
            <th>Metric</th>
            <th>MXB Formula</th>
            <th>Newton Method</th>
        </tr>
        <tr>
            <td>Mean Absolute Error</td>
            <td>2.28 × 10<sup>-7</sup></td>
            <td>3.08 × 10<sup>1</sup></td>
        </tr>
        <tr>
            <td>Maximum Absolute Error</td>
            <td>1.28 × 10<sup>-3</sup></td>
            <td>7.70 × 10<sup>1</sup></td>
        </tr>
    </table>
    
    <h1 style="margin-top: 2em;">Key Advantages</h1 style="margin-top: 2em;">
    <ul>
        <li><strong>Computational Efficiency:</strong> Our method requires only one computational step versus multiple iterations.</li>
        <li><strong>Predictable Performance:</strong> Unlike iterative methods whose convergence speed can vary, our formula delivers consistent results in constant time.</li>
        <li><strong>Simplicity:</strong> The implementation is straightforward, requiring only basic arithmetic operations.</li>
    </ul>
    
    <h1 style="margin-top: 2em;">Potential Limitations</h1 style="margin-top: 2em;">
    <ul>
        <li><strong>Small Numbers:</strong> As demonstrated in our analysis, the formula shows slightly higher error rates for smaller numbers compared to very large numbers.</li>
        <li><strong>Special Cases:</strong> Edge cases like perfect squares or numbers very close to perfect squares might benefit from special handling for optimal performance.</li>
    </ul>
    
    <h1 style="margin-top: 2em;">Example Calculation</h1 style="margin-top: 2em;">
    <p>Let's try an example to make this clear. What is the square root of 52?
    The nearest perfect square smaller than 52 is 49, with square root 7.
    So, b = 7, b² = 49, and m = 52 - 49 = 3.
    Substituting these values into MXB equation:</p>
    
    <div class="equation">
        a = (9(28+1) + 4 · 3 · 49 · (14+1))/(9 + 4 · 7(4 · 343 + 2 · 49 + 3 · 7 · 3 + 3))<br>
        a = (9 · 29 + 12 · 49 · 15)/(9 + 28(1372 + 98 + 63 + 3))<br>
        a = (261 + 8820)/(9 + 28 · 1536)<br>
        a = 9081/43017<br>
        a ≈ 0.211102587
    </div>
    
    <p>Now, add a to b to find the square root of 52:</p>
    
    <div class="equation">
        b + a = √x<br>
        7 + 0.211102587 = √52<br>
        7.211102587 ≈ √52
    </div>
    
    <p>Squaring this result: 7.211102587² ≈ 52.00000052, which is remarkably close to 52!</p>
    
    <div class="image-container">
        <img src="./images/52-sqr.png" alt="Square root of 52" class="article-image">
    </div>
    <div class="caption">Figure 6: Square root of 52</div>
    
    <h1 style="margin-top: 2em;">Verification with Large Numbers</h1 style="margin-top: 2em;">
    <p>To demonstrate the exceptional accuracy of our formula, I tested it with 10 randomly generated large numbers ranging from 100,000 to 1,000,000,000. The results confirm the formula's precision and efficiency.</p>
    
    <table>
        <caption>Square Root Calculations for Large Random Numbers</caption>
        <tr>
            <th>Random Number</th>
            <th>Calculated √x</th>
            <th>True √x</th>
            <th>Absolute Error</th>
            <th>Relative Error (%)</th>
        </tr>
        <tr>
            <td>810,883,942</td>
            <td>28,476.7075608507</td>
            <td>28,476.7075608507</td>
            <td>5.46 × 10<sup>-11</sup></td>
            <td>1.92 × 10<sup>-13</sup></td>
        </tr>
        <tr>
            <td>340,395,796</td>
            <td>18,449.8244422571</td>
            <td>18,449.8244422571</td>
            <td>0.00 × 10<sup>0</sup></td>
            <td>0.00 × 10<sup>0</sup></td>
        </tr>
        <tr>
            <td>600,881,721</td>
            <td>24,513.5050793609</td>
            <td>24,513.5050793609</td>
            <td>0.00 × 10<sup>0</sup></td>
            <td>0.00 × 10<sup>0</sup></td>
        </tr>
        <tr>
            <td>468,325,081</td>
            <td>21,640.5861970587</td>
            <td>21,640.5861970587</td>
            <td>0.00 × 10<sup>0</sup></td>
            <td>0.00 × 10<sup>0</sup></td>
        </tr>
        <tr>
            <td>301,932,587</td>
            <td>17,376.7850018285</td>
            <td>17,376.7850018285</td>
            <td>0.00 × 10<sup>0</sup></td>
            <td>0.00 × 10<sup>0</sup></td>
        </tr>
        <tr>
            <td>993,975,206</td>
            <td>31,528.0302485644</td>
            <td>31,528.0302485644</td>
            <td>0.00 × 10<sup>0</sup></td>
            <td>0.00 × 10<sup>0</sup></td>
        </tr>
        <tr>
            <td>306,778,246</td>
            <td>17,515.6629003695</td>
            <td>17,515.6629003695</td>
            <td>0.00 × 10<sup>0</sup></td>
            <td>0.00 × 10<sup>0</sup></td>
        </tr>
        <tr>
            <td>821,989,455</td>
            <td>28,670.1785970246</td>
            <td>28,670.1785970246</td>
            <td>0.00 × 10<sup>0</sup></td>
            <td>0.00 × 10<sup>0</sup></td>
        </tr>
        <tr>
            <td>490,705,189</td>
            <td>22,152.0017172154</td>
            <td>22,152.0017172154</td>
            <td>3.64 × 10<sup>-12</sup></td>
            <td>1.64 × 10<sup>-14</sup></td>
        </tr>
        <tr>
            <td>707,721,128</td>
            <td>26,602.0852050023</td>
            <td>26,602.0852050023</td>
            <td>0.00 × 10<sup>0</sup></td>
            <td>0.00 × 10<sup>0</sup></td>
        </tr>
    </table>
    
    <p><strong>Average absolute error:</strong> 5.82 × 10<sup>-12</sup><br>
    <strong>Average relative error:</strong> 2.05 × 10<sup>-14</sup> %</p>
    
    <h1 style="margin-top: 2em;">Validation by Squaring Results</h1 style="margin-top: 2em;">
    <p>To further verify the accuracy, I squared each calculated square root to check how closely the result matches the original number:</p>
    
    <table>
        <caption>Verification of Results by Squaring</caption>
        <tr>
            <th>Random Number</th>
            <th>(Calculated √x)²</th>
            <th>Difference from x</th>
        </tr>
        <tr>
            <td>810,883,942</td>
            <td>810,883,942.0000000</td>
            <td>3.52 × 10<sup>-6</sup></td>
        </tr>
        <tr>
            <td>340,395,796</td>
            <td>340,395,796.0000000</td>
            <td>0.00 × 10<sup>0</sup></td>
        </tr>
        <tr>
            <td>600,881,721</td>
            <td>600,881,721.0000000</td>
            <td>0.00 × 10<sup>0</sup></td>
        </tr>
        <tr>
            <td>468,325,081</td>
            <td>468,325,081.0000000</td>
            <td>0.00 × 10<sup>0</sup></td>
        </tr>
        <tr>
            <td>301,932,587</td>
            <td>301,932,587.0000000</td>
            <td>0.00 × 10<sup>0</sup></td>
        </tr>
        <tr>
            <td>993,975,206</td>
            <td>993,975,206.0000001</td>
            <td>0.00 × 10<sup>0</sup></td>
        </tr>
        <tr>
            <td>306,778,246</td>
            <td>306,778,246.0000000</td>
            <td>0.00 × 10<sup>0</sup></td>
        </tr>
        <tr>
            <td>821,989,455</td>
            <td>821,989,455.0000000</td>
            <td>0.00 × 10<sup>0</sup></td>
        </tr>
        <tr>
            <td>490,705,189</td>
            <td>490,705,189.0000000</td>
            <td>0.00 × 10<sup>0</sup></td>
        </tr>
        <tr>
            <td>707,721,128</td>
            <td>707,721,128.0000000</td>
            <td>0.00 × 10<sup>0</sup></td>
        </tr>
    </table>
    
    <h1 style="margin-top: 2em;">Analysis of Results</h1 style="margin-top: 2em;">
    <p>The formula performs exceptionally well:</p>
    <ol>
        <li><strong>Accuracy:</strong> The absolute errors are extremely small, on the order of 10<sup>-11</sup> or smaller. For 8 out of 10 numbers, the formula produces results numerically identical to traditional square root functions (to the precision shown).</li>
        <li><strong>Relative Error:</strong> The relative errors are around 10<sup>-14</sup>% or smaller, which is remarkably close to machine precision.</li>
        <li><strong>Verification:</strong> When squaring the calculated square roots, we obtain values virtually identical to the original numbers, with differences at most around 10<sup>-6</sup>.</li>
    </ol>
    
    <p>This verification confirms that the formula works particularly well for large numbers, aligning with our earlier observation that the distribution of square roots appears more evenly spaced at larger values. This non-iterative formula provides square root calculations with precision comparable to traditional methods but without requiring iterations, demonstrating its practical value for computational applications.</p>
    
    <h1 style="margin-top: 2em;">Algorithm Implementation</h1 style="margin-top: 2em;">
    <p>The algorithm can be formalized in pseudocode as follows:</p>
    
    <div class="algorithm">
        <h1 style="margin-top: 2em;">Algorithm: MXB Non-Iterative Square Root</h1 style="margin-top: 2em;">
        <ol>
            <li>Function NonIterativeSqrt(x):
                <ul>
                    <li>b ← ⌊√x⌋ <span class="comment">/* Find largest perfect square less than x */</span></li>
                    <li>b_squared ← b²</li>
                    <li>m ← x - b_squared <span class="comment">/* Difference between x and nearest perfect square */</span></li>
                    <li>numerator ← m² · (4b + 1) + 4 · m · b² · (2b + 1)</li>
                    <li>denominator ← m² + 4b · (4b³ + 2b² + 3b · m + m)</li>
                    <li>a ← numerator / denominator</li>
                    <li>Return b + a</li>
                </ul>
            </li>
        </ol>
    </div>
    
    <h1 style="margin-top: 2em;">What Makes This Formula Special</h1 style="margin-top: 2em;">
    <p>Unlike traditional approaches that require iteration or sacrifice accuracy, this formula delivers excellent precision to the decimal places instantly.
    For example, calculating square root of 52 yields 7.211102587—virtually identical to the true value.</p>
    
    <h1 style="margin-top: 2em;">Key Advantages</h1 style="margin-top: 2em;">
    <ul><li>Single-Step Calculation: No iteration required</li>
        <li>Exceptional Accuracy: Precision that rivals iterative methods</li>
        <li>Universal Application: Works across the entire natural number system</li>
        <li>Computational Efficiency: Ideal for systems where iterative methods are impractical</li>
        <li>Mathematical Innovation: A fresh approach to one of the oldest mathematical operations!</li>
    </ul>
    
    <h1 style="margin-top: 2em;">Conclusion</h1 style="margin-top: 2em;">
    <p>This paper presents a new non-iterative approach to square root computation that achieves high precision without the need for iterative refinement. The formula leverages mathematical properties of square roots and their distribution to provide accurate results in a single calculation step. As demonstrated through extensive testing with large numbers, the method produces results with negligible error rates, often matching traditional methods to machine precision. In computational environments where iterative methods are impractical or inefficient, such as certain embedded systems or real-time applications, this formula offers a viable alternative.</p>
    <p>Future work could explore potential optimizations of the formula for specific number ranges, applications to other root calculations, and hardware implementations that could further leverage the non-iterative nature of this approach.</p>



  </main>
  <div id="imageModal" class="modal">
    <span class="close">&times;</span>
    <div class="modal-content-container" id="modalContainer">
      <img class="modal-content" id="expandedImg">
    </div>
    <div class="zoom-controls">
      <button class="zoom-btn" id="zoom-out">−</button>
      <button class="zoom-btn" id="zoom-in">+</button>
      <button class="zoom-btn" id="zoom-reset">⟲</button>
    </div>
  </div>
  <footer class="bg-gray-700 text-white text-center p-4 mt-auto">
    <p>© 2025 Content licensed under <a href="LICENSE" class="underline">MIT License</a>.</p>
  </footer>
  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const modal = document.getElementById("imageModal");
      const modalImg = document.getElementById("expandedImg");
      const modalContainer = document.getElementById("modalContainer");
      const closeBtn = document.getElementsByClassName("close")[0];
      const images = document.getElementsByClassName("article-image");
      const zoomIn = document.getElementById("zoom-in");
      const zoomOut = document.getElementById("zoom-out");
      const zoomReset = document.getElementById("zoom-reset");
      
      let currentZoom = 1;
      const zoomStep = 0.25;
      const maxZoom = 3;
      const minZoom = 0.5;
      
      let isDragging = false;
      let startX, startY;
      let translateX = 0;
      let translateY = 0;
      
      function handleZoomIn() {
        if (currentZoom < maxZoom) {
          currentZoom += zoomStep;
          updateZoom();
        }
      }
      
      function handleZoomOut() {
        if (currentZoom > minZoom) {
          currentZoom -= zoomStep;
          updateZoom();
        }
      }
      
      function handleZoomReset() {
        currentZoom = 1;
        translateX = 0;
        translateY = 0;
        updateZoom();
      }
      
      function updateZoom() {
        modalImg.style.transform = `translate(${translateX}px, ${translateY}px) scale(${currentZoom})`;
      }
      
      modalImg.addEventListener('mousedown', function(e) {
        if (currentZoom > 1) {
          isDragging = true;
          startX = e.clientX - translateX;
          startY = e.clientY - translateY;
          modalImg.style.cursor = 'grabbing';
        }
      });
      
      document.addEventListener('mousemove', function(e) {
        if (isDragging) {
          translateX = e.clientX - startX;
          translateY = e.clientY - startY;
          updateZoom();
        }
      });
      
      document.addEventListener('mouseup', function() {
        isDragging = false;
        modalImg.style.cursor = 'grab';
      });
      
      modalImg.addEventListener('touchstart', function(e) {
        if (e.touches.length === 1 && currentZoom > 1) {
          isDragging = true;
          startX = e.touches[0].clientX - translateX;
          startY = e.touches[0].clientY - translateY;
        } else if (e.touches.length === 2) {
          // Pinch zoom logic
          initialDistance = Math.hypot(
            e.touches[0].pageX - e.touches[1].pageX,
            e.touches[0].pageY - e.touches[1].pageY
          );
        }
      }, { passive: false });
      
      document.addEventListener('touchmove', function(e) {
        if (isDragging && e.touches.length === 1) {
          e.preventDefault();
          translateX = e.touches[0].clientX - startX;
          translateY = e.touches[0].clientY - startY;
          updateZoom();
        } else if (e.touches.length === 2) {
          e.preventDefault();
          
          const currentDistance = Math.hypot(
            e.touches[0].pageX - e.touches[1].pageX,
            e.touches[0].pageY - e.touches[1].pageY
          );
          
          if (initialDistance > 0) {
            if (currentDistance > initialDistance + 10 && currentZoom < maxZoom) {
              currentZoom += zoomStep;
              updateZoom();
              initialDistance = currentDistance;
            } else if (currentDistance < initialDistance - 10 && currentZoom > minZoom) {
              currentZoom -= zoomStep;
              updateZoom();
              initialDistance = currentDistance;
            }
          }
        }
      }, { passive: false });
      
      document.addEventListener('touchend', function() {
        isDragging = false;
      });
      
      zoomIn.addEventListener('click', handleZoomIn);
      zoomOut.addEventListener('click', handleZoomOut);
      zoomReset.addEventListener('click', handleZoomReset);
      
      modalImg.addEventListener('wheel', function(e) {
        e.preventDefault();
        if (e.deltaY < 0) {
          handleZoomIn();
        } else {
          handleZoomOut();
        }
      });
      
      let initialDistance = 0;
      
      let lastTap = 0;
      modalImg.addEventListener('touchend', function(e) {
        const currentTime = new Date().getTime();
        const tapLength = currentTime - lastTap;
        
        if (tapLength < 300 && tapLength > 0) {
          if (currentZoom > 1) {
            handleZoomReset();
          } else {
            currentZoom = 2;
            updateZoom();
          }
          e.preventDefault();
        }
        
        lastTap = currentTime;
      });
      
      for (let i = 0; i < images.length; i++) {
        images[i].addEventListener('click', function() {
          modal.style.display = "flex";
          modalImg.src = this.src;
          document.body.style.overflow = "hidden";
          currentZoom = 1;
          translateX = 0;
          translateY = 0;
          updateZoom();
          modalImg.style.cursor = 'grab';
        });
      }
      
      closeBtn.addEventListener('click', function() {
        modal.style.display = "none";
        document.body.style.overflow = ""; 
      });
      
      modal.addEventListener('click', function(event) {
        if (event.target === modal || event.target === modalContainer) {
          modal.style.display = "none";
          document.body.style.overflow = ""; 
        }
      });
      
      document.addEventListener('keydown', function(e) {
        if (modal.style.display === "flex") {
          if (e.key === "Escape") {
            modal.style.display = "none";
            document.body.style.overflow = "";
          } else if (e.key === "+" || e.key === "=") {
            handleZoomIn();
          } else if (e.key === "-") {
            handleZoomOut();
          } else if (e.key === "0") {
            handleZoomReset();
          }
        }
      });
    });
  </script>
</body>
</html>
